package cc.blynk.server.notifications.push;

import cc.blynk.server.notifications.push.request.RequestMessage;
import cc.blynk.server.notifications.push.response.ACKMessage;
import cc.blynk.server.notifications.push.response.ControlMessage;
import cc.blynk.server.notifications.push.response.NACKMessage;
import cc.blynk.server.notifications.push.response.enums.ControlType;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jivesoftware.smack.ConnectionConfiguration;
import org.jivesoftware.smack.SmackException;
import org.jivesoftware.smack.XMPPConnection;
import org.jivesoftware.smack.XMPPException;
import org.jivesoftware.smack.filter.PacketTypeFilter;
import org.jivesoftware.smack.packet.Message;
import org.jivesoftware.smack.packet.Packet;
import org.jivesoftware.smack.provider.PacketExtensionProvider;
import org.jivesoftware.smack.provider.ProviderManager;
import org.jivesoftware.smack.tcp.XMPPTCPConnection;

import javax.net.ssl.SSLSocketFactory;
import java.io.IOException;
import java.util.Map;
import java.util.UUID;

import static cc.blynk.server.notifications.push.GCMPacketExtension.GCM_ELEMENT_NAME;
import static cc.blynk.server.notifications.push.GCMPacketExtension.GCM_NAMESPACE;

/**
 * The Blynk Project.
 * Created by Dmitriy Dumanskiy.
 * Created on 2/8/2015.
 */
public class GCMSmackCcsClient {

//it is threadsafe
    static final ObjectMapper mapper = new ObjectMapper()
            .setSerializationInclusion(JsonInclude.Include.NON_NULL)
            .setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
    private static final Logger log = LogManager.getLogger(GCMSmackCcsClient.class);

    static {
        ProviderManager.addExtensionProvider(GCM_ELEMENT_NAME, GCM_NAMESPACE,
                (PacketExtensionProvider) parser -> {
                    String json = parser.nextText();
                    return new GCMPacketExtension(json);
                });
    }

    private final String host;;
private final int port;
    /**
     * Indicates whether the connection is in draining state, which means that it
     * will not accept any new downstream messages.
     */
    protected volatile boolean connectionDraining = false;
    private XMPPConnection connection;

    public GCMSmackCcsClient(String host, int port) {
        this.host = host;
        this.port = port;
    }

    /**
     * Returns a random message id to uniquely identify a message.
     *
     * <p>Note: This is generated by a pseudo random number generator for
     * illustration purpose, and is not guaranteed to be unique.
     */
    public static String generateUniqueMesageId() {
        return UUID.randomUUID().toString();
    }

        /**
         * Creates a JSON encoded GCM message.
         *
         * @param to RegistrationId of the target device (Required).
         * @param messageId Unique messageId for which CCS will send an
         *         "ack/nack" (Required).
         * @param data Message content intended for the application. (Optional).
         * @param timeToLive GCM time_to_live parameter (Optional).
         * @param delayWhileIdle GCM delay_while_idle parameter (Optional).
         * @return JSON encoded GCM message.
         */
        public static String createRequest(String to, String messageId,
                                           Map<String, String> data, long timeToLive,
                                           boolean delayWhileIdle) throws JsonProcessingException {
            RequestMessage responseMessage = new RequestMessage(to, messageId, data, timeToLive, delayWhileIdle);
            return mapper.writeValueAsString(responseMessage);
        }

    /**
     * Sends a downstream message to GCM.
     *
     * @return true if the message has been successfully sent.
     */
    public boolean sendDownstreamMessage(String jsonRequest) throws SmackException.NotConnectedException {
        if (!connectionDraining) {
            send(jsonRequest);
            return true;
        }
        //todo reconnect
        log.error("Dropping downstream message since the connection is draining");
        return false;
    }

    /**
     * Sends a packet with contents provided.
     */
    protected void send(String jsonRequest) throws SmackException.NotConnectedException {
        Packet request = new GCMPacketExtension(jsonRequest).toPacket();
        connection.sendPacket(request);
    }

    /**
     * Handles an ACK.
     *
     * <p>Logs a INFO message, but subclasses could override it to
     * properly handle ACKs.
     */
    protected void handleAckReceipt(ACKMessage ackMessage) {

    }

    /**
     * Handles a NACK.
     *
     * <p>Logs a INFO message, but subclasses could override it to
     * properly handle NACKs.
     */
    protected void handleNackReceipt(NACKMessage nackMessage) {
        throw new RuntimeException(nackMessage.error + "; " + nackMessage);
    }

    protected void handleControlMessage(ControlMessage controlMessage) {
        log.info("handleControlMessage(): " + controlMessage);
        if (ControlType.CONNECTION_DRAINING == controlMessage.control_type) {
            connectionDraining = true;
            //todo reconnect
        } else {
            log.warn("Unrecognized control type: {}. This could happen if new features are added to the CCS protocol.", controlMessage.control_type);
        }
    }

        /**
         * Connects to GCM Cloud Connection Server using the supplied credentials.
         *
         * @param senderId Your GCM project number
         * @param apiKey API Key of your project
         */
        public void connect(long senderId, String apiKey) throws XMPPException, IOException, SmackException {
            ConnectionConfiguration config = new ConnectionConfiguration(host, port);
            config.setSecurityMode(ConnectionConfiguration.SecurityMode.enabled);
            config.setReconnectionAllowed(true);
            config.setRosterLoadedAtLogin(false);
            config.setSendPresence(false);
            config.setSocketFactory(SSLSocketFactory.getDefault());

            connection = new XMPPTCPConnection(config);
            connection.connect();

            connection.addConnectionListener(new LoggingConnectionListener());

            // Handle incoming packets
            connection.addPacketListener(new MyPacketListener(this), new PacketTypeFilter(Message.class));

            // Log all outgoing packets
            connection.addPacketInterceptor(packet -> log.debug("Sent: {}", packet.toXML()), new PacketTypeFilter(Message.class));

            connection.login(senderId + "@gcm.googleapis.com", apiKey);
        }

}
